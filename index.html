<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Plants vs Zombies Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background: #333; font-family: sans-serif; }
        canvas { display: block; margin: 0 auto; background: #90EE90; border: 2px solid #000; }
        #ui {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(139, 69, 19, 0.9); padding: 10px 20px; border-radius: 10px;
            color: white; font-size: 20px; text-align: center; border: 2px solid #5c2e0e;
        }
        .plant-card {
            display: inline-block; width: 50px; height: 50px; background: #228B22;
            margin-left: 15px; cursor: pointer; border: 2px solid #fff; vertical-align: middle;
            line-height: 50px; font-size: 12px;
        }
        .plant-card:hover { border-color: yellow; }
    </style>
</head>
<body>

<div id="ui">
    Sun: <span id="sunDisplay">100</span>
    <div class="plant-card" onclick="selectPlant()">Peashooter (50)</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Настройки
    const GRID_SIZE = 80;
    const ROWS = 5;
    const COLS = 9;
    const HEADER_HEIGHT = 100; // Отступ сверху для меню

    canvas.width = COLS * GRID_SIZE;
    canvas.height = ROWS * GRID_SIZE + HEADER_HEIGHT;

    // Состояние игры
    let sun = 100;
    let frame = 0;
    let gameOver = false;
    let selectedPlant = false; // Выбрано ли растение для посадки

    // Списки объектов
    const plants = [];
    const zombies = [];
    const projectiles = [];
    const suns = [];

    // --- Классы ---

    class Plant {
        constructor(col, row) {
            this.col = col;
            this.row = row;
            this.x = col * GRID_SIZE;
            this.y = row * GRID_SIZE + HEADER_HEIGHT;
            this.health = 100;
            this.timer = 0;
            this.color = '#228B22'; // ForestGreen
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x + 10, this.y + 10, GRID_SIZE - 20, GRID_SIZE - 20);
            // Глаза
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.x + 50, this.y + 30, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        update() {
            this.timer++;
            // Стрельба каждые 1.5 секунды (90 кадров при 60fps)
            // Проверяем, есть ли зомби на линии
            const zombieOnRow = zombies.some(z => z.row === this.row && z.x > this.x);

            if (this.timer % 90 === 0 && zombieOnRow) {
                projectiles.push(new Projectile(this.x + 50, this.y + 40));
            }
        }
    }

    class Zombie {
        constructor(row) {
            this.row = row;
            this.x = canvas.width;
            this.y = row * GRID_SIZE + HEADER_HEIGHT;
            this.health = 100;
            this.speed = 0.5;
            this.damage = 0.5;
            this.color = '#B22222'; // FireBrick
            this.eating = false;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x + 15, this.y + 10, GRID_SIZE - 30, GRID_SIZE - 20);
            // Лицо
            ctx.fillStyle = '#98FB98';
            ctx.fillRect(this.x + 20, this.y + 15, 20, 20);
        }

        update() {
            this.eating = false;
            // Проверка коллизии с растениями
            for (let i = 0; i < plants.length; i++) {
                let p = plants[i];
                if (p.row === this.row &&
                    this.x < p.x + GRID_SIZE - 20 &&
                    this.x + GRID_SIZE - 30 > p.x + 10) {

                    this.eating = true;
                    p.health -= this.damage;
                    if (p.health <= 0) {
                        plants.splice(i, 1);
                        i--;
                    }
                }
            }

            if (!this.eating) {
                this.x -= this.speed;
            }

            if (this.x < 0) {
                gameOver = true;
            }
        }
    }

    class Projectile {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.speed = 5;
            this.radius = 5;
            this.markedForDeletion = false;
        }

        draw() {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        update() {
            this.x += this.speed;
            if (this.x > canvas.width) this.markedForDeletion = true;

            for (let z of zombies) {
                if (!z.markedForDeletion &&
                    this.x > z.x + 15 &&
                    this.x < z.x + GRID_SIZE - 15 &&
                    this.y > z.y + 10 &&
                    this.y < z.y + GRID_SIZE - 10) {

                    z.health -= 20;
                    this.markedForDeletion = true;
                    if (z.health <= 0) {
                        z.markedForDeletion = true;
                        sun += 25; // Награда за зомби
                        updateUI();
                    }
                }
            }
        }
    }

    // --- Управление ---

    function selectPlant() {
        if (sun >= 50) {
            selectedPlant = true;
            document.body.style.cursor = 'crosshair';
        }
    }

    canvas.addEventListener('mousedown', function(e) {
        if (!selectedPlant) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Игнорируем клики в меню
        if (y < HEADER_HEIGHT) return;

        const col = Math.floor(x / GRID_SIZE);
        const row = Math.floor((y - HEADER_HEIGHT) / GRID_SIZE);

        // Проверяем, не занята ли клетка
        const occupied = plants.some(p => p.col === col && p.row === row);

        if (!occupied && sun >= 50) {
            plants.push(new Plant(col, row));
            sun -= 50;
            selectedPlant = false;
            document.body.style.cursor = 'default';
            updateUI();
        }
    });

    function updateUI() {
        document.getElementById('sunDisplay').innerText = Math.floor(sun);
    }

    // --- Главный цикл ---

    function animate() {
        if (gameOver) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'red';
            ctx.font = '50px Arial';
            ctx.fillText("THE ZOMBIES ATE YOUR BRAINS!", 40, canvas.height / 2);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Отрисовка сетки
        // Фон травы
        ctx.fillStyle = '#90EE90';
        ctx.fillRect(0, HEADER_HEIGHT, canvas.width, canvas.height - HEADER_HEIGHT);

        // Линии
        ctx.strokeStyle = '#77aa77';
        for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(x, HEADER_HEIGHT); ctx.lineTo(x, canvas.height); ctx.stroke();
        }
        for (let y = HEADER_HEIGHT; y <= canvas.height; y += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
        }

        // Верхнее меню (фон)
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, 0, canvas.width, HEADER_HEIGHT);


        // Логика спавна зомби
        frame++;
        if (frame % 300 === 0) { // Каждые ~5 секунд
            const r = Math.floor(Math.random() * ROWS);
            zombies.push(new Zombie(r));
        }
        // Пассивный доход солнца
        if (frame % 600 === 0) {
            sun += 25;
            updateUI();
        }

        // Обновление и отрисовка
        plants.forEach(p => { p.update(); p.draw(); });

        for (let i = 0; i < zombies.length; i++) {
            zombies[i].update();
            zombies[i].draw();
            if (zombies[i].markedForDeletion) {
                zombies.splice(i, 1);
                i--;
            }
        }

        for (let i = 0; i < projectiles.length; i++) {
            projectiles[i].update();
            projectiles[i].draw();
            if (projectiles[i].markedForDeletion) {
                projectiles.splice(i, 1);
                i--;
            }
        }

        requestAnimationFrame(animate);
    }

    animate();

</script>
</body>
</html>
